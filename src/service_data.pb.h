// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service_data.proto

#ifndef PROTOBUF_INCLUDED_service_5fdata_2eproto
#define PROTOBUF_INCLUDED_service_5fdata_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_service_5fdata_2eproto 

namespace protobuf_service_5fdata_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_service_5fdata_2eproto
namespace ServiceData {
class Chirp;
class ChirpDefaultTypeInternal;
extern ChirpDefaultTypeInternal _Chirp_default_instance_;
class NowChirpId;
class NowChirpIdDefaultTypeInternal;
extern NowChirpIdDefaultTypeInternal _NowChirpId_default_instance_;
class Timestamp;
class TimestampDefaultTypeInternal;
extern TimestampDefaultTypeInternal _Timestamp_default_instance_;
class User;
class UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
class UserChirpList;
class UserChirpListDefaultTypeInternal;
extern UserChirpListDefaultTypeInternal _UserChirpList_default_instance_;
class UserFollowingList;
class UserFollowingListDefaultTypeInternal;
extern UserFollowingListDefaultTypeInternal _UserFollowingList_default_instance_;
}  // namespace ServiceData
namespace google {
namespace protobuf {
template<> ::ServiceData::Chirp* Arena::CreateMaybeMessage<::ServiceData::Chirp>(Arena*);
template<> ::ServiceData::NowChirpId* Arena::CreateMaybeMessage<::ServiceData::NowChirpId>(Arena*);
template<> ::ServiceData::Timestamp* Arena::CreateMaybeMessage<::ServiceData::Timestamp>(Arena*);
template<> ::ServiceData::User* Arena::CreateMaybeMessage<::ServiceData::User>(Arena*);
template<> ::ServiceData::UserChirpList* Arena::CreateMaybeMessage<::ServiceData::UserChirpList>(Arena*);
template<> ::ServiceData::UserFollowingList* Arena::CreateMaybeMessage<::ServiceData::UserFollowingList>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace ServiceData {

// ===================================================================

class Timestamp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ServiceData.Timestamp) */ {
 public:
  Timestamp();
  virtual ~Timestamp();

  Timestamp(const Timestamp& from);

  inline Timestamp& operator=(const Timestamp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Timestamp(Timestamp&& from) noexcept
    : Timestamp() {
    *this = ::std::move(from);
  }

  inline Timestamp& operator=(Timestamp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Timestamp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Timestamp* internal_default_instance() {
    return reinterpret_cast<const Timestamp*>(
               &_Timestamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Timestamp* other);
  friend void swap(Timestamp& a, Timestamp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Timestamp* New() const final {
    return CreateMaybeMessage<Timestamp>(NULL);
  }

  Timestamp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Timestamp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Timestamp& from);
  void MergeFrom(const Timestamp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Timestamp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 seconds = 1;
  void clear_seconds();
  static const int kSecondsFieldNumber = 1;
  ::google::protobuf::int64 seconds() const;
  void set_seconds(::google::protobuf::int64 value);

  // int64 useconds = 2;
  void clear_useconds();
  static const int kUsecondsFieldNumber = 2;
  ::google::protobuf::int64 useconds() const;
  void set_useconds(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ServiceData.Timestamp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 seconds_;
  ::google::protobuf::int64 useconds_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class User : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ServiceData.User) */ {
 public:
  User();
  virtual ~User();

  User(const User& from);

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(User&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const User& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(User* other);
  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline User* New() const final {
    return CreateMaybeMessage<User>(NULL);
  }

  User* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<User>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // .ServiceData.Timestamp last_update = 2;
  bool has_last_update() const;
  void clear_last_update();
  static const int kLastUpdateFieldNumber = 2;
  private:
  const ::ServiceData::Timestamp& _internal_last_update() const;
  public:
  const ::ServiceData::Timestamp& last_update() const;
  ::ServiceData::Timestamp* release_last_update();
  ::ServiceData::Timestamp* mutable_last_update();
  void set_allocated_last_update(::ServiceData::Timestamp* last_update);

  // @@protoc_insertion_point(class_scope:ServiceData.User)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::ServiceData::Timestamp* last_update_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserFollowingList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ServiceData.UserFollowingList) */ {
 public:
  UserFollowingList();
  virtual ~UserFollowingList();

  UserFollowingList(const UserFollowingList& from);

  inline UserFollowingList& operator=(const UserFollowingList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserFollowingList(UserFollowingList&& from) noexcept
    : UserFollowingList() {
    *this = ::std::move(from);
  }

  inline UserFollowingList& operator=(UserFollowingList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserFollowingList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserFollowingList* internal_default_instance() {
    return reinterpret_cast<const UserFollowingList*>(
               &_UserFollowingList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(UserFollowingList* other);
  friend void swap(UserFollowingList& a, UserFollowingList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserFollowingList* New() const final {
    return CreateMaybeMessage<UserFollowingList>(NULL);
  }

  UserFollowingList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserFollowingList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserFollowingList& from);
  void MergeFrom(const UserFollowingList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserFollowingList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string username = 1;
  int username_size() const;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username(int index) const;
  ::std::string* mutable_username(int index);
  void set_username(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_username(int index, ::std::string&& value);
  #endif
  void set_username(int index, const char* value);
  void set_username(int index, const char* value, size_t size);
  ::std::string* add_username();
  void add_username(const ::std::string& value);
  #if LANG_CXX11
  void add_username(::std::string&& value);
  #endif
  void add_username(const char* value);
  void add_username(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& username() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_username();

  // @@protoc_insertion_point(class_scope:ServiceData.UserFollowingList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> username_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserChirpList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ServiceData.UserChirpList) */ {
 public:
  UserChirpList();
  virtual ~UserChirpList();

  UserChirpList(const UserChirpList& from);

  inline UserChirpList& operator=(const UserChirpList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserChirpList(UserChirpList&& from) noexcept
    : UserChirpList() {
    *this = ::std::move(from);
  }

  inline UserChirpList& operator=(UserChirpList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserChirpList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserChirpList* internal_default_instance() {
    return reinterpret_cast<const UserChirpList*>(
               &_UserChirpList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(UserChirpList* other);
  friend void swap(UserChirpList& a, UserChirpList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserChirpList* New() const final {
    return CreateMaybeMessage<UserChirpList>(NULL);
  }

  UserChirpList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserChirpList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserChirpList& from);
  void MergeFrom(const UserChirpList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserChirpList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 chirp_id = 1;
  int chirp_id_size() const;
  void clear_chirp_id();
  static const int kChirpIdFieldNumber = 1;
  ::google::protobuf::uint64 chirp_id(int index) const;
  void set_chirp_id(int index, ::google::protobuf::uint64 value);
  void add_chirp_id(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      chirp_id() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_chirp_id();

  // @@protoc_insertion_point(class_scope:ServiceData.UserChirpList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > chirp_id_;
  mutable int _chirp_id_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Chirp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ServiceData.Chirp) */ {
 public:
  Chirp();
  virtual ~Chirp();

  Chirp(const Chirp& from);

  inline Chirp& operator=(const Chirp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Chirp(Chirp&& from) noexcept
    : Chirp() {
    *this = ::std::move(from);
  }

  inline Chirp& operator=(Chirp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Chirp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Chirp* internal_default_instance() {
    return reinterpret_cast<const Chirp*>(
               &_Chirp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Chirp* other);
  friend void swap(Chirp& a, Chirp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Chirp* New() const final {
    return CreateMaybeMessage<Chirp>(NULL);
  }

  Chirp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Chirp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Chirp& from);
  void MergeFrom(const Chirp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Chirp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 children_ids = 6;
  int children_ids_size() const;
  void clear_children_ids();
  static const int kChildrenIdsFieldNumber = 6;
  ::google::protobuf::uint64 children_ids(int index) const;
  void set_children_ids(int index, ::google::protobuf::uint64 value);
  void add_children_ids(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      children_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_children_ids();

  // string username = 2;
  void clear_username();
  static const int kUsernameFieldNumber = 2;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string text = 4;
  void clear_text();
  static const int kTextFieldNumber = 4;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // .ServiceData.Timestamp time = 5;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 5;
  private:
  const ::ServiceData::Timestamp& _internal_time() const;
  public:
  const ::ServiceData::Timestamp& time() const;
  ::ServiceData::Timestamp* release_time();
  ::ServiceData::Timestamp* mutable_time();
  void set_allocated_time(::ServiceData::Timestamp* time);

  // uint64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // uint64 parent_id = 3;
  void clear_parent_id();
  static const int kParentIdFieldNumber = 3;
  ::google::protobuf::uint64 parent_id() const;
  void set_parent_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ServiceData.Chirp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > children_ids_;
  mutable int _children_ids_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::ServiceData::Timestamp* time_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint64 parent_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NowChirpId : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ServiceData.NowChirpId) */ {
 public:
  NowChirpId();
  virtual ~NowChirpId();

  NowChirpId(const NowChirpId& from);

  inline NowChirpId& operator=(const NowChirpId& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NowChirpId(NowChirpId&& from) noexcept
    : NowChirpId() {
    *this = ::std::move(from);
  }

  inline NowChirpId& operator=(NowChirpId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NowChirpId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NowChirpId* internal_default_instance() {
    return reinterpret_cast<const NowChirpId*>(
               &_NowChirpId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(NowChirpId* other);
  friend void swap(NowChirpId& a, NowChirpId& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NowChirpId* New() const final {
    return CreateMaybeMessage<NowChirpId>(NULL);
  }

  NowChirpId* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NowChirpId>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NowChirpId& from);
  void MergeFrom(const NowChirpId& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NowChirpId* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 now_id = 1;
  void clear_now_id();
  static const int kNowIdFieldNumber = 1;
  ::google::protobuf::uint64 now_id() const;
  void set_now_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ServiceData.NowChirpId)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 now_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_5fdata_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Timestamp

// int64 seconds = 1;
inline void Timestamp::clear_seconds() {
  seconds_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Timestamp::seconds() const {
  // @@protoc_insertion_point(field_get:ServiceData.Timestamp.seconds)
  return seconds_;
}
inline void Timestamp::set_seconds(::google::protobuf::int64 value) {
  
  seconds_ = value;
  // @@protoc_insertion_point(field_set:ServiceData.Timestamp.seconds)
}

// int64 useconds = 2;
inline void Timestamp::clear_useconds() {
  useconds_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Timestamp::useconds() const {
  // @@protoc_insertion_point(field_get:ServiceData.Timestamp.useconds)
  return useconds_;
}
inline void Timestamp::set_useconds(::google::protobuf::int64 value) {
  
  useconds_ = value;
  // @@protoc_insertion_point(field_set:ServiceData.Timestamp.useconds)
}

// -------------------------------------------------------------------

// User

// string username = 1;
inline void User::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& User::username() const {
  // @@protoc_insertion_point(field_get:ServiceData.User.username)
  return username_.GetNoArena();
}
inline void User::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ServiceData.User.username)
}
#if LANG_CXX11
inline void User::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ServiceData.User.username)
}
#endif
inline void User::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ServiceData.User.username)
}
inline void User::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ServiceData.User.username)
}
inline ::std::string* User::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:ServiceData.User.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_username() {
  // @@protoc_insertion_point(field_release:ServiceData.User.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:ServiceData.User.username)
}

// .ServiceData.Timestamp last_update = 2;
inline bool User::has_last_update() const {
  return this != internal_default_instance() && last_update_ != NULL;
}
inline void User::clear_last_update() {
  if (GetArenaNoVirtual() == NULL && last_update_ != NULL) {
    delete last_update_;
  }
  last_update_ = NULL;
}
inline const ::ServiceData::Timestamp& User::_internal_last_update() const {
  return *last_update_;
}
inline const ::ServiceData::Timestamp& User::last_update() const {
  const ::ServiceData::Timestamp* p = last_update_;
  // @@protoc_insertion_point(field_get:ServiceData.User.last_update)
  return p != NULL ? *p : *reinterpret_cast<const ::ServiceData::Timestamp*>(
      &::ServiceData::_Timestamp_default_instance_);
}
inline ::ServiceData::Timestamp* User::release_last_update() {
  // @@protoc_insertion_point(field_release:ServiceData.User.last_update)
  
  ::ServiceData::Timestamp* temp = last_update_;
  last_update_ = NULL;
  return temp;
}
inline ::ServiceData::Timestamp* User::mutable_last_update() {
  
  if (last_update_ == NULL) {
    auto* p = CreateMaybeMessage<::ServiceData::Timestamp>(GetArenaNoVirtual());
    last_update_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ServiceData.User.last_update)
  return last_update_;
}
inline void User::set_allocated_last_update(::ServiceData::Timestamp* last_update) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete last_update_;
  }
  if (last_update) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      last_update = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, last_update, submessage_arena);
    }
    
  } else {
    
  }
  last_update_ = last_update;
  // @@protoc_insertion_point(field_set_allocated:ServiceData.User.last_update)
}

// -------------------------------------------------------------------

// UserFollowingList

// repeated string username = 1;
inline int UserFollowingList::username_size() const {
  return username_.size();
}
inline void UserFollowingList::clear_username() {
  username_.Clear();
}
inline const ::std::string& UserFollowingList::username(int index) const {
  // @@protoc_insertion_point(field_get:ServiceData.UserFollowingList.username)
  return username_.Get(index);
}
inline ::std::string* UserFollowingList::mutable_username(int index) {
  // @@protoc_insertion_point(field_mutable:ServiceData.UserFollowingList.username)
  return username_.Mutable(index);
}
inline void UserFollowingList::set_username(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ServiceData.UserFollowingList.username)
  username_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void UserFollowingList::set_username(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ServiceData.UserFollowingList.username)
  username_.Mutable(index)->assign(std::move(value));
}
#endif
inline void UserFollowingList::set_username(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  username_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ServiceData.UserFollowingList.username)
}
inline void UserFollowingList::set_username(int index, const char* value, size_t size) {
  username_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ServiceData.UserFollowingList.username)
}
inline ::std::string* UserFollowingList::add_username() {
  // @@protoc_insertion_point(field_add_mutable:ServiceData.UserFollowingList.username)
  return username_.Add();
}
inline void UserFollowingList::add_username(const ::std::string& value) {
  username_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ServiceData.UserFollowingList.username)
}
#if LANG_CXX11
inline void UserFollowingList::add_username(::std::string&& value) {
  username_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ServiceData.UserFollowingList.username)
}
#endif
inline void UserFollowingList::add_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  username_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ServiceData.UserFollowingList.username)
}
inline void UserFollowingList::add_username(const char* value, size_t size) {
  username_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ServiceData.UserFollowingList.username)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
UserFollowingList::username() const {
  // @@protoc_insertion_point(field_list:ServiceData.UserFollowingList.username)
  return username_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
UserFollowingList::mutable_username() {
  // @@protoc_insertion_point(field_mutable_list:ServiceData.UserFollowingList.username)
  return &username_;
}

// -------------------------------------------------------------------

// UserChirpList

// repeated uint64 chirp_id = 1;
inline int UserChirpList::chirp_id_size() const {
  return chirp_id_.size();
}
inline void UserChirpList::clear_chirp_id() {
  chirp_id_.Clear();
}
inline ::google::protobuf::uint64 UserChirpList::chirp_id(int index) const {
  // @@protoc_insertion_point(field_get:ServiceData.UserChirpList.chirp_id)
  return chirp_id_.Get(index);
}
inline void UserChirpList::set_chirp_id(int index, ::google::protobuf::uint64 value) {
  chirp_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:ServiceData.UserChirpList.chirp_id)
}
inline void UserChirpList::add_chirp_id(::google::protobuf::uint64 value) {
  chirp_id_.Add(value);
  // @@protoc_insertion_point(field_add:ServiceData.UserChirpList.chirp_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
UserChirpList::chirp_id() const {
  // @@protoc_insertion_point(field_list:ServiceData.UserChirpList.chirp_id)
  return chirp_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
UserChirpList::mutable_chirp_id() {
  // @@protoc_insertion_point(field_mutable_list:ServiceData.UserChirpList.chirp_id)
  return &chirp_id_;
}

// -------------------------------------------------------------------

// Chirp

// uint64 id = 1;
inline void Chirp::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Chirp::id() const {
  // @@protoc_insertion_point(field_get:ServiceData.Chirp.id)
  return id_;
}
inline void Chirp::set_id(::google::protobuf::uint64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:ServiceData.Chirp.id)
}

// string username = 2;
inline void Chirp::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Chirp::username() const {
  // @@protoc_insertion_point(field_get:ServiceData.Chirp.username)
  return username_.GetNoArena();
}
inline void Chirp::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ServiceData.Chirp.username)
}
#if LANG_CXX11
inline void Chirp::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ServiceData.Chirp.username)
}
#endif
inline void Chirp::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ServiceData.Chirp.username)
}
inline void Chirp::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ServiceData.Chirp.username)
}
inline ::std::string* Chirp::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:ServiceData.Chirp.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Chirp::release_username() {
  // @@protoc_insertion_point(field_release:ServiceData.Chirp.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Chirp::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:ServiceData.Chirp.username)
}

// uint64 parent_id = 3;
inline void Chirp::clear_parent_id() {
  parent_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Chirp::parent_id() const {
  // @@protoc_insertion_point(field_get:ServiceData.Chirp.parent_id)
  return parent_id_;
}
inline void Chirp::set_parent_id(::google::protobuf::uint64 value) {
  
  parent_id_ = value;
  // @@protoc_insertion_point(field_set:ServiceData.Chirp.parent_id)
}

// string text = 4;
inline void Chirp::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Chirp::text() const {
  // @@protoc_insertion_point(field_get:ServiceData.Chirp.text)
  return text_.GetNoArena();
}
inline void Chirp::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ServiceData.Chirp.text)
}
#if LANG_CXX11
inline void Chirp::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ServiceData.Chirp.text)
}
#endif
inline void Chirp::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ServiceData.Chirp.text)
}
inline void Chirp::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ServiceData.Chirp.text)
}
inline ::std::string* Chirp::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:ServiceData.Chirp.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Chirp::release_text() {
  // @@protoc_insertion_point(field_release:ServiceData.Chirp.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Chirp::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:ServiceData.Chirp.text)
}

// .ServiceData.Timestamp time = 5;
inline bool Chirp::has_time() const {
  return this != internal_default_instance() && time_ != NULL;
}
inline void Chirp::clear_time() {
  if (GetArenaNoVirtual() == NULL && time_ != NULL) {
    delete time_;
  }
  time_ = NULL;
}
inline const ::ServiceData::Timestamp& Chirp::_internal_time() const {
  return *time_;
}
inline const ::ServiceData::Timestamp& Chirp::time() const {
  const ::ServiceData::Timestamp* p = time_;
  // @@protoc_insertion_point(field_get:ServiceData.Chirp.time)
  return p != NULL ? *p : *reinterpret_cast<const ::ServiceData::Timestamp*>(
      &::ServiceData::_Timestamp_default_instance_);
}
inline ::ServiceData::Timestamp* Chirp::release_time() {
  // @@protoc_insertion_point(field_release:ServiceData.Chirp.time)
  
  ::ServiceData::Timestamp* temp = time_;
  time_ = NULL;
  return temp;
}
inline ::ServiceData::Timestamp* Chirp::mutable_time() {
  
  if (time_ == NULL) {
    auto* p = CreateMaybeMessage<::ServiceData::Timestamp>(GetArenaNoVirtual());
    time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ServiceData.Chirp.time)
  return time_;
}
inline void Chirp::set_allocated_time(::ServiceData::Timestamp* time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete time_;
  }
  if (time) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    
  } else {
    
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:ServiceData.Chirp.time)
}

// repeated uint64 children_ids = 6;
inline int Chirp::children_ids_size() const {
  return children_ids_.size();
}
inline void Chirp::clear_children_ids() {
  children_ids_.Clear();
}
inline ::google::protobuf::uint64 Chirp::children_ids(int index) const {
  // @@protoc_insertion_point(field_get:ServiceData.Chirp.children_ids)
  return children_ids_.Get(index);
}
inline void Chirp::set_children_ids(int index, ::google::protobuf::uint64 value) {
  children_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:ServiceData.Chirp.children_ids)
}
inline void Chirp::add_children_ids(::google::protobuf::uint64 value) {
  children_ids_.Add(value);
  // @@protoc_insertion_point(field_add:ServiceData.Chirp.children_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Chirp::children_ids() const {
  // @@protoc_insertion_point(field_list:ServiceData.Chirp.children_ids)
  return children_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Chirp::mutable_children_ids() {
  // @@protoc_insertion_point(field_mutable_list:ServiceData.Chirp.children_ids)
  return &children_ids_;
}

// -------------------------------------------------------------------

// NowChirpId

// uint64 now_id = 1;
inline void NowChirpId::clear_now_id() {
  now_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 NowChirpId::now_id() const {
  // @@protoc_insertion_point(field_get:ServiceData.NowChirpId.now_id)
  return now_id_;
}
inline void NowChirpId::set_now_id(::google::protobuf::uint64 value) {
  
  now_id_ = value;
  // @@protoc_insertion_point(field_set:ServiceData.NowChirpId.now_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ServiceData

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_service_5fdata_2eproto
